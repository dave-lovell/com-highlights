---
title: "05_data cleaning"
format: html
editor: visual
---

### Libraries

```{r libs}
#| messages: false
library(here)
library(dplyr)
library(vroom)
library(stringr)
library(purrr)
library(rlang) # for nice error handling
library(lobstr)
```

## Setup

### Read in Census Table

```{r readInCensusTable}
census_table <- readRDS(here("data", "intermediate", "census", "merged-data", "02_grouped-by-level-and-nation_2022-10-25.RDS"))

tree(census_table, max_depth = 5)
```

## Read in Helpers

```{r readHelpers}

## modify_census_tibbles -----------------------------------------------------
## Wrapper around a for loop. Modifies `census_table` at specified 'addresses'
## modify_census_tibbles(x, modify_func, ..., nations, levels, stats)

modify_census_tibbles <- readRDS(here("functions", "modify-census.RDS"))

## selector -------------------------------------------------------------------
## Function factory: makes select functions with specified args.
## Helpful for selecting flexibly amidst slightly inconsistent tables
## selector(...)
## eg. select_geo_codes <- selector(matches("oa_id"), matches("sa_id"))
## select_geo_codes(x, starts_with("something_"))
selector <- readRDS(here("functions", "selector.RDS"))
```

```{r renamingColoumns}

remove_prefix <- function(x, sep, regex = FALSE){
  
  if(!regex){ sep <- stringr::fixed(sep) }
  
  sep_end <- stringr::str_locate(x, sep)[, "end"] 
  
  if(any(is.na(sep_end))){
    na_seps <- which(is.na(sep_end))
    sep_end[na_seps] <- 0
    
    # for(i in na_seps) warning("Separator '", sep, "' not found in colunm name '", x[[i]] , "'")
    }
  
  string_out <- str_sub(x, sep_end + 1)
  
  return(string_out)
                 
}

census_table <-
  modify_census_tibbles(
    census_table,
    modify_func = rename_with,
    .fn = remove_prefix,
    .cols = everything(),
    sep = "..")

#RENAMING ETHNICITY TABLES for England, Wales & Scotland 

census_select_ews <- function(x, ...){
  select(x,
         ## com/dioceses/nation
         matches("com"), matches("diocese"), matches("nation"),
         ## Diocese-level fields
         matches("parish_code"), matches("oa_id"),
         ## Nation-level fields
         matches("geo_code"), matches("sa_id"),
         ...)
}

# census_select_ews <- function(x){
  census_select_ews <- selector(
    matches("com"), matches("diocese"), matches("nation"),
    matches("parish_code"), matches("oa_id"),
    matches("geo_code"), matches("sa_id")
         )

## Not quite: `selector` is a function-factory that we read in from elsewhere.
## A function-factory is a funciton that returns a function. It works like this:
  ### custom_select <- selector(mpg, cyl)
  ### ^ custom_select is a function that always selects `mpg` and `cyl`, 
  ### plus anything else that's passed to it
  ### custom_select(mtcars, drat) # select `drat`, `mpg` and `cyl` from mtcars 


  ## So we can make 'census_select_ews()` like so:
# # census_select_ews <- selector(
#          ## com/dioceses/nation
#          matches("com"), matches("diocese"), matches("nation"),
#          ## Diocese-level fields
#          matches("parish_code"), matches("oa_id"),
#          ## Nation-level fields
#          matches("geo_code"), matches("sa_id")
#          )
  

tmp <-
  modify_census_tibbles(
    census_table,
    modify_func = census_select_ews,
    white_or_white_british,
    black_or_black_british,
    asian_or_asian_british,
    mixed_multiple_ethnicity,
    other_ethnicity,
    stats = "ethn",
    nations = c("England", "Wales", "Scotland")
    )

#Renaming age ok
census_table <-
  modify_census_tibbles(
    census_table,
    modify_func = rename_with,
    
    .fn = str_replace,
    .cols = starts_with("x"),
    
    "x", "age_",
    
    stats = "pop"
)

# drop all suffix _health in health analysis ok
 census_table <-
   modify_census_tibbles(
     census_table,
     modify_func = rename_with,
     
     .fn = str_replace,
     .cols = ends_with("_health"),
     "_health", "",
     
  stats = "health",
  nations = c("Wales", "Scotland", "Northern-Ireland", "England")
 )
 
 # drop total person ok
 census_table <-
   modify_census_tibbles(
     census_table,
     modify_func = select,
     
     .cols = -starts_with("total"),
     
     stats = c("ethn", "health", "house", "rel")
   )
 
 
 #rename of column proportion of oa - Ireland & Northern Ireland ok
 ## Make a silly function that will work with 'rename_with()'
 ## Might crash if it tries to rename multiple columns - good!
 make_name_com_prop <- function(x){
   "com_prop"
 }
 
 census_table <-
   modify_census_tibbles(
     census_table,
     rename_with,
     
     cols = matches("proportion_of_._within_co_m_boundary"),
     .fn  = make_name_com_prop
 )

 
 #Add _persons to pop tables of Northern Ireland& Repulblic of Ireland
 census_table <-
   modify_census_tibbles(
     census_table,
     modify_func = rename,
     
     male   = "male_persons",
     female = "female_persons",
     
     stats = "pop",
     nations = c("Repulblic-of Ireland", "Northern-Ireland")
   )




```

```{r multiply the proportion across all columns}

multiplier <- function(x){
  
  prop_column = df[ , 5]
  
  round(prop_column) <- function(prop_column)
    round((prop_column), digits = 0)
          if prop_column > 1
          else round((prop_column), 1)}
  
  
  df(prop_column) %>% mutate_at(vars(starts_with("[ , 6]")), ~.*deflator)
  ## instead of mutate_at, use mutate(across())
  ## starts_with wants a character string
  
  x <- some_table_nice
  
  x <- mutate(x, prop_column = min(prop_column, 1))
  
  require(magritrr)
  
  x <- mutate(x, 
              across(
                where(is.numeric),
                multiply_by, 
                prop_column))
  
  
  round(df[ , 5], digits = 1) -> exceed 1
}
  
map(coms_by_nation, 
    
    ## not sure what goes here...
    
    mutate,
    across(where(is.numeric)),
    multiply_by,
    proportion_of_oa_within_co_m_boundary
    )

```
